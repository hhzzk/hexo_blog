title: "编程之美：数学之魅（２）"
date: 2016-04-16 21:05:57
tags:
  - 面试题
  - 算法
categories:
  - 原创
  - 算法系列
thumbnailImagePosition: left
thumbnailImage: http://7xrt06.com1.z0.glb.clouddn.com/16-4-12/14915809.jpg
---

不要被阶乘吓倒、寻找数组中的最大值和最小值、快速寻找满足条件的两个数、子数组的最大乘积、数组的分割、区间重合判断。
<!-- excerpt -->

<!-- toc -->
## 一. 不要被阶乘吓倒
两个与阶乘相关的问题：
1） 给定一个整数N，那么N的阶乘 `N！`末尾有多少个0呢？
2） 求 `N！` 的二进制表示中最低位1的位置

**方案一**
问题一中要求 `N!` 末尾有多少个0，其实就是 `1，2，3，...,N` 这些数中能乘出多少个10，我们知道2和5相乘可以得到一个10，所以可以对 `N!` 进行质数分解，$N!=2^X*3^Y*5^Z...$ ，于是我们只要算出 X, Z 最小的那个值即可。又因为能被2整除的数出现的频率比能被5整除的数高的多，所以只要求出 Z 即可。
问题最终转化成了求 `N!` 中含有质因数5的个数。
```c
ret = 0
for(i = 1; i <= N; i++)
{
    j = i;
    while(j % 5 == 0)
    {
        ret++;
        j /= 5;
    }
}
```
## 二. 寻找数组中的最大值和最小值
对于一个包含N个元素的数组，需要比较多少次才能把最大值和最小值找出来？

**方案一**
定义两个变量 `MAX` 和 `MIN` ，分别保存最大值和最小值。按顺序遍历数组，每次取出两个元素，首先比较两个数组元素，较大的元素和 `MAX` 比较，如果大于 `MAX`，则用此元素替换掉 `MAX` 的值。然后较小的元素和 `MIN` 比较，如果小于 `MIN`， 则用此元素替换掉 `MIN` 的值。比较过程如下图:

![](http://7xrt06.com1.z0.glb.clouddn.com/16-4-12/10258855.jpg)

整个过程的比较次数为 `1.5N`。

**方案二**
方案二采用分治法，将数组分为两部分，分别求出 `MAX` 和 `MIN`，最后将两部分的最大值和最小值再作比较。但这种方法的比较次数仍然没有减少。

## 三. 快速寻找满足条件的两个数
能够快速找出一个数组中的两个数，使得这两个数的和等于给定的某个特定值。假设符合条件的两个数一定存在。

**方案一**
假设给定的和为`Sum`，根据题目的要求既是,对于每一个数组元素 `arr[i]`,数组中是否存在 `Sum-arr[i]`。
首先将数组排序，所需的时间复杂度为$O(Nlog_2 N)$。查找的时候采用二分查找的方式，这样每一次查找的时间复杂度为$O(log_2 N)$，而总的查找时间复杂度也是$O(Nlog_2 N)$。因为只需要排序一次，所以整个算法的时间复杂度为$O(Nlog_2 N)$。

**方案二**
首先将数组排序，所需的时间复杂度为$O(Nlog_2 N)$。
令 `i = 0， j = n-1`, 首先判断 `arr[i]` 和 `arr[j]` 的和是否等于 `Sum`, 如果相等则退出，否则如果大于 `Sum` 则 `j--` ，如果小于  `Sum` 则 `i++`。这个过程只需要遍历一次数组，时间复杂度为 $O(N)$。
两步加起来的时间复杂度也是$O(Nlog_2 N)$。
伪代码：
```c
for(i = 0, j = n - 1; i < j;)
{
    if(arr[i] + arr[j] == Sum)
        return (i, j);
    else if(arr[i] + arr[j] < Sum)
        i++;
    else
        j--;
    
    return (-1, -1);
}
```

## 四. 子数组的最大乘积

给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意一个 `N-1` 个数组合的乘积中最大的一组。

**方案一**
假设N个数的乘积为P，对P的正负性进行分析：

- 如果P为0：
    那么数组中一定存在0，假设去掉一个0之后的乘积为Q，根据Q的正负性进行讨论：
    - Q为0：
        说明数组中至少有两个0，那么 `N-1` 个数组的乘积一定为0.
    - Q为正：
        说明Q既是最大的乘积。
    - Q为负：
        说明0既是最大的乘积，用0替换掉任意一个元素即可。

- 如果P为正：
    说明数组中没有负数或者负数的个数正好是偶数，所以应该去掉一个最小的正数，这样余下的元素既是乘积最大的那一组。

- 如果P为负：
    说明数组中的负数为奇数个，所以应该去掉一个负数，这样可以保证乘积为正。如果想要余下的元素乘积最大，那么去掉的负数应该是绝对值最小的那个。

因为 `N` 个数的乘积有可能出现溢出的情况，所以可以通过计算数组中正数、负数、0的个数的情况进行判断。

因为只需要遍历数组一次，所以时间复杂度为 $O(N)$。

## 五. 数组的分割

有一个乱序，元素个数为 `2n` 的正整数数组，如何能够把这个数组分割为元素个数为 `n` 的两个数组，并使两个数组的和接近。

**方案一**

## 六. 区间重合判断
![](http://7xrt06.com1.z0.glb.clouddn.com/16-4-13/63982355.jpg)

**方案一**
先将目标区间排序，例如： [2,3][1,2][3,9] -> [1,2][2,3][3,9] 。 排序方法安装首元素排序。
将排序后的目标区间合并成若干个不相交的区间，举例中可以合并成一个区间：
[1,2][2,3][3,9] -> [1,9]。合并时判断相邻区间是否首尾相交。q
采用二分查找判断源区间是否在某个目标区间中。因为合并后的若干个区间是有序的，所以采用二分查找法。

时间复杂度：
排序时间复杂度： $O(N*log_2 N)$ (其中N是目标区间的个数)
合并区间的时间复杂度： $O(N)$
查找的时间复杂度： $O(log_2 N)$
***
(EOF)

